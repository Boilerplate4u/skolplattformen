/* eslint-disable */
// tslint:disable
/**
 * $kolplattformen API
 * This is a first try to extract a usable API based on the expensive SOA crap that is called Skolplattformen in Stockholm

# Introduction
This API is a wrapper on top of the SOA layer behind **Skolplattformen** which is the mandatory platform for schools in Stockholm Stad. 

# Get Started
Generate code examples from the OpenAPI yaml (press Download above) or use this as a start:
```
    const socialSecurityNumber = '121212121212'
    const baseUrl = 'https://api.skolplattformen.org'
    const token = await fetch(`${baseUrl}/login?socialSecurityNumber=${socialSecurityNumber}`, {method: 'POST'}).then(res => res.json())
    
    // Now start BankID and authorize, when you do - your jwt token will be ready
    const jwt = await fetch(`${baseUrl}/login/${token.order}/jwt`).then(res => res.json())
    const headers = {authorization: 'Bearer ' + jwt}

    // Use the jwt token as bearer token in your requests
    const children = await fetch(`${baseUrl}/children`, {headers}).then(res => res.json())

    // Get some details
    const childId = children[0].id
    const child = await fetch(`${baseUrl}/children/${childId}`, {headers}).then(res => res.json())
    const news = await fetch(`${baseUrl}/children/${childId}/news`, {headers}).then(res => res.json())
    const calendar = await fetch(`${baseUrl}/children/${childId}/calendar`, {headers}).then(res => res.json())

```

# Open source
This project is provided AS IS and is provided free as open source. If you want to participate and add more features to this api. Please find at the repository here:
[https://github.com/kolplattformen/api](https://github.com/kolplattformen/api)

# Privacy considerations
This API encodes the cookies recieved from the backend servers as JWT tokens and send them encrypted to the client. Neither cookies or tokens are stored on the server.

# Disclaimers
I have no affiliate with the Stockholm Stad organisation or any part of any development team for the city. Therefore things may change and suddenly stop working and I have no way of knowing or even a way of contacting you. My motivation for creating this API is purely for personal reasons. I want to develop apps for my own use and have no interest to go deep in the underlying SDK every day so I'm using this API as a way of creating a little bit of sanity and conform the sometimes swinglish structure into something a little bit more consistant. 

 *
 * OpenAPI spec version: 1.0.0
 * Contact: christian.landgren@iteam.se
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

/// <reference path="./custom.d.ts" />

import url from "url";
import portableFetch from "portable-fetch";
import { Configuration } from "./configuration";
import { BASE_PATH, COLLECTION_FORMATS, FetchAPI, FetchArgs, BaseAPI, RequiredError } from "./runtime";
import { Api } from "./models";

/**
 * ChildrenApi - fetch parameter creator
 * @export
 */
export const ChildrenApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Get list of calendar events</p>
		 * @summary Calendar
		 * @param {string} childId Child Id (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCalendar(childId: string, options: any = {}): FetchArgs {
			// verify required parameter 'childId' is not null or undefined
			if (childId === null || childId === undefined) {
				throw new RequiredError('childId', 'Required parameter childId was null or undefined when calling getCalendar.');
			}
			const localVarPath = `/children/{childId}/calendar`
				.replace('{childId}', encodeURIComponent(String(childId)));
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http basic authentication required
			if (configuration && (configuration.username || configuration.password)) {
				localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Get all info for this this child</p>
		 * @summary Child
		 * @param {string} childId Child Id (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getChildById(childId: string, options: any = {}): FetchArgs {
			// verify required parameter 'childId' is not null or undefined
			if (childId === null || childId === undefined) {
				throw new RequiredError('childId', 'Required parameter childId was null or undefined when calling getChildById.');
			}
			const localVarPath = `/children/{childId}`
				.replace('{childId}', encodeURIComponent(String(childId)));
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http basic authentication required
			if (configuration && (configuration.username || configuration.password)) {
				localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Receive a list of children available through the API to the logged in user Important to only show children you are eligble to see :)</p>
		 * @summary List Children
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getChildren(options: any = {}): FetchArgs {
			const localVarPath = `/children`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http basic authentication required
			if (configuration && (configuration.username || configuration.password)) {
				localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Get list of class mates and guardians in this childs class</p>
		 * @summary Classmates
		 * @param {string} childSdsId Child SdsId (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClassmates(childSdsId: string, options: any = {}): FetchArgs {
			// verify required parameter 'childSdsId' is not null or undefined
			if (childSdsId === null || childSdsId === undefined) {
				throw new RequiredError('childSdsId', 'Required parameter childSdsId was null or undefined when calling getClassmates.');
			}
			const localVarPath = `/children/{childSdsId}/classmates`
				.replace('{childSdsId}', encodeURIComponent(String(childSdsId)));
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http basic authentication required
			if (configuration && (configuration.username || configuration.password)) {
				localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Get food menu for the week for this child</p>
		 * @summary Lunch Menu
		 * @param {string} childId Child Id (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getMenu(childId: string, options: any = {}): FetchArgs {
			// verify required parameter 'childId' is not null or undefined
			if (childId === null || childId === undefined) {
				throw new RequiredError('childId', 'Required parameter childId was null or undefined when calling getMenu.');
			}
			const localVarPath = `/children/{childId}/menu`
				.replace('{childId}', encodeURIComponent(String(childId)));
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http basic authentication required
			if (configuration && (configuration.username || configuration.password)) {
				localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Get list of news items for this child</p>
		 * @summary News
		 * @param {string} childId Child Id (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getNews(childId: string, options: any = {}): FetchArgs {
			// verify required parameter 'childId' is not null or undefined
			if (childId === null || childId === undefined) {
				throw new RequiredError('childId', 'Required parameter childId was null or undefined when calling getNews.');
			}
			const localVarPath = `/children/{childId}/news`
				.replace('{childId}', encodeURIComponent(String(childId)));
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Get list of notifications for this child</p>
		 * @summary Notifications
		 * @param {string} childSdsId Child sdsId (received from /children) (this is a separate id than childId for some reason, probably a subsystem)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getNotifications(childSdsId: string, options: any = {}): FetchArgs {
			// verify required parameter 'childSdsId' is not null or undefined
			if (childSdsId === null || childSdsId === undefined) {
				throw new RequiredError('childSdsId', 'Required parameter childSdsId was null or undefined when calling getNotifications.');
			}
			const localVarPath = `/children/{childSdsId}/notifications`
				.replace('{childSdsId}', encodeURIComponent(String(childSdsId)));
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http basic authentication required
			if (configuration && (configuration.username || configuration.password)) {
				localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Get list of news items for this child</p>
		 * @summary Schedule
		 * @param {string} childSdsId Child SdsId (received from /children) (this is a separate id than childId for some reason, probably a subsystem)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSchedule(childSdsId: string, options: any = {}): FetchArgs {
			// verify required parameter 'childSdsId' is not null or undefined
			if (childSdsId === null || childSdsId === undefined) {
				throw new RequiredError('childSdsId', 'Required parameter childSdsId was null or undefined when calling getSchedule.');
			}
			const localVarPath = `/children/{childSdsId}/schedule`
				.replace('{childSdsId}', encodeURIComponent(String(childSdsId)));
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http basic authentication required
			if (configuration && (configuration.username || configuration.password)) {
				localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ChildrenApi - functional programming interface
 * @export
 */
export const ChildrenApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Get list of calendar events</p>
		 * @summary Calendar
		 * @param {string} childId Child Id (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCalendar(childId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Api.CalendarItem[]> {
			const localVarFetchArgs = ChildrenApiFetchParamCreator(configuration).getCalendar(childId, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Get all info for this this child</p>
		 * @summary Child
		 * @param {string} childId Child Id (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getChildById(childId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ChildAll> {
			const localVarFetchArgs = ChildrenApiFetchParamCreator(configuration).getChildById(childId, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Receive a list of children available through the API to the logged in user Important to only show children you are eligble to see :)</p>
		 * @summary List Children
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getChildren(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Api.Child[]> {
			const localVarFetchArgs = ChildrenApiFetchParamCreator(configuration).getChildren(options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Get list of class mates and guardians in this childs class</p>
		 * @summary Classmates
		 * @param {string} childSdsId Child SdsId (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClassmates(childSdsId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Api.Classmate[]> {
			const localVarFetchArgs = ChildrenApiFetchParamCreator(configuration).getClassmates(childSdsId, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Get food menu for the week for this child</p>
		 * @summary Lunch Menu
		 * @param {string} childId Child Id (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getMenu(childId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = ChildrenApiFetchParamCreator(configuration).getMenu(childId, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response;
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Get list of news items for this child</p>
		 * @summary News
		 * @param {string} childId Child Id (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getNews(childId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Api.NewsItem[]> {
			const localVarFetchArgs = ChildrenApiFetchParamCreator(configuration).getNews(childId, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Get list of notifications for this child</p>
		 * @summary Notifications
		 * @param {string} childSdsId Child sdsId (received from /children) (this is a separate id than childId for some reason, probably a subsystem)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getNotifications(childSdsId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Api.Notification[]> {
			const localVarFetchArgs = ChildrenApiFetchParamCreator(configuration).getNotifications(childSdsId, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Get list of news items for this child</p>
		 * @summary Schedule
		 * @param {string} childSdsId Child SdsId (received from /children) (this is a separate id than childId for some reason, probably a subsystem)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSchedule(childSdsId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = ChildrenApiFetchParamCreator(configuration).getSchedule(childSdsId, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response;
					} else {
						throw response;
					}
				});
			};
		},
	}
};

/**
 * ChildrenApi - factory interface
 * @export
 */
export const ChildrenApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 * <p>Get list of calendar events</p>
		 * @summary Calendar
		 * @param {string} childId Child Id (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCalendar(childId: string, options?: any) {
			return ChildrenApiFp(configuration).getCalendar(childId, options)(fetch, basePath);
		},
		/**
		 * <p>Get all info for this this child</p>
		 * @summary Child
		 * @param {string} childId Child Id (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getChildById(childId: string, options?: any) {
			return ChildrenApiFp(configuration).getChildById(childId, options)(fetch, basePath);
		},
		/**
		 * <p>Receive a list of children available through the API to the logged in user Important to only show children you are eligble to see :)</p>
		 * @summary List Children
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getChildren(options?: any) {
			return ChildrenApiFp(configuration).getChildren(options)(fetch, basePath);
		},
		/**
		 * <p>Get list of class mates and guardians in this childs class</p>
		 * @summary Classmates
		 * @param {string} childSdsId Child SdsId (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClassmates(childSdsId: string, options?: any) {
			return ChildrenApiFp(configuration).getClassmates(childSdsId, options)(fetch, basePath);
		},
		/**
		 * <p>Get food menu for the week for this child</p>
		 * @summary Lunch Menu
		 * @param {string} childId Child Id (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getMenu(childId: string, options?: any) {
			return ChildrenApiFp(configuration).getMenu(childId, options)(fetch, basePath);
		},
		/**
		 * <p>Get list of news items for this child</p>
		 * @summary News
		 * @param {string} childId Child Id (received from /children)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getNews(childId: string, options?: any) {
			return ChildrenApiFp(configuration).getNews(childId, options)(fetch, basePath);
		},
		/**
		 * <p>Get list of notifications for this child</p>
		 * @summary Notifications
		 * @param {string} childSdsId Child sdsId (received from /children) (this is a separate id than childId for some reason, probably a subsystem)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getNotifications(childSdsId: string, options?: any) {
			return ChildrenApiFp(configuration).getNotifications(childSdsId, options)(fetch, basePath);
		},
		/**
		 * <p>Get list of news items for this child</p>
		 * @summary Schedule
		 * @param {string} childSdsId Child SdsId (received from /children) (this is a separate id than childId for some reason, probably a subsystem)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSchedule(childSdsId: string, options?: any) {
			return ChildrenApiFp(configuration).getSchedule(childSdsId, options)(fetch, basePath);
		},
	};
};

/**
 * ChildrenApi - object-oriented interface
 * @export
 * @class ChildrenApi
 * @extends {BaseAPI}
 */
export class ChildrenApi extends BaseAPI {
	/**
	 * <p>Get list of calendar events</p>
	 * @summary Calendar
	 * @param {string} childId Child Id (received from /children)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChildrenApi
	 */
	public getCalendar(childId: string, options?: any) {
		return ChildrenApiFp(this.configuration).getCalendar(childId, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Get all info for this this child</p>
	 * @summary Child
	 * @param {string} childId Child Id (received from /children)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChildrenApi
	 */
	public getChildById(childId: string, options?: any) {
		return ChildrenApiFp(this.configuration).getChildById(childId, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Receive a list of children available through the API to the logged in user Important to only show children you are eligble to see :)</p>
	 * @summary List Children
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChildrenApi
	 */
	public getChildren(options?: any) {
		return ChildrenApiFp(this.configuration).getChildren(options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Get list of class mates and guardians in this childs class</p>
	 * @summary Classmates
	 * @param {string} childSdsId Child SdsId (received from /children)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChildrenApi
	 */
	public getClassmates(childSdsId: string, options?: any) {
		return ChildrenApiFp(this.configuration).getClassmates(childSdsId, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Get food menu for the week for this child</p>
	 * @summary Lunch Menu
	 * @param {string} childId Child Id (received from /children)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChildrenApi
	 */
	public getMenu(childId: string, options?: any) {
		return ChildrenApiFp(this.configuration).getMenu(childId, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Get list of news items for this child</p>
	 * @summary News
	 * @param {string} childId Child Id (received from /children)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChildrenApi
	 */
	public getNews(childId: string, options?: any) {
		return ChildrenApiFp(this.configuration).getNews(childId, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Get list of notifications for this child</p>
	 * @summary Notifications
	 * @param {string} childSdsId Child sdsId (received from /children) (this is a separate id than childId for some reason, probably a subsystem)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChildrenApi
	 */
	public getNotifications(childSdsId: string, options?: any) {
		return ChildrenApiFp(this.configuration).getNotifications(childSdsId, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Get list of news items for this child</p>
	 * @summary Schedule
	 * @param {string} childSdsId Child SdsId (received from /children) (this is a separate id than childId for some reason, probably a subsystem)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChildrenApi
	 */
	public getSchedule(childSdsId: string, options?: any) {
		return ChildrenApiFp(this.configuration).getSchedule(childSdsId, options)(this.fetch, this.basePath);
	}

}
/**
 * LoginApi - fetch parameter creator
 * @export
 */
export const LoginApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Get auth cookie for BankID login. This endpoint will initiate a login and require the user to login through BankID. When finished you will recieve a token that can be sent to the status endpoint to recieve a jwt token when authorized through BankID.</p>
		 * @summary Login
		 * @param {string} socialSecurityNumber Swedish social security number connected to BankID
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		login(socialSecurityNumber: string, options: any = {}): FetchArgs {
			// verify required parameter 'socialSecurityNumber' is not null or undefined
			if (socialSecurityNumber === null || socialSecurityNumber === undefined) {
				throw new RequiredError('socialSecurityNumber', 'Required parameter socialSecurityNumber was null or undefined when calling login.');
			}
			const localVarPath = `/login`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (socialSecurityNumber !== undefined) {
				localVarQueryParameter['socialSecurityNumber'] = socialSecurityNumber;
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Recieve the status of the order token after the user has approved the authorization request in the BankID app, this endpoint will return a jwt token that can be used for the subsequential requests. This request will wait up until two minutes for a response.</p>
		 * @summary Wait for Jwt token
		 * @param {string} order Order token received from the /login endpoint
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		waitForToken(order: string, options: any = {}): FetchArgs {
			// verify required parameter 'order' is not null or undefined
			if (order === null || order === undefined) {
				throw new RequiredError('order', 'Required parameter order was null or undefined when calling waitForToken.');
			}
			const localVarPath = `/login/{order}/jwt`
				.replace('{order}', encodeURIComponent(String(order)));
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Get auth cookie for BankID login. This endpoint will initiate a login and require the user to login through BankID. When finished you will recieve a token that can be sent to the status endpoint to recieve a jwt token when authorized through BankID.</p>
		 * @summary Login
		 * @param {string} socialSecurityNumber Swedish social security number connected to BankID
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		login(socialSecurityNumber: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Api.Auth> {
			const localVarFetchArgs = LoginApiFetchParamCreator(configuration).login(socialSecurityNumber, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Recieve the status of the order token after the user has approved the authorization request in the BankID app, this endpoint will return a jwt token that can be used for the subsequential requests. This request will wait up until two minutes for a response.</p>
		 * @summary Wait for Jwt token
		 * @param {string} order Order token received from the /login endpoint
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		waitForToken(order: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Api.AuthToken> {
			const localVarFetchArgs = LoginApiFetchParamCreator(configuration).waitForToken(order, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
	}
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 * <p>Get auth cookie for BankID login. This endpoint will initiate a login and require the user to login through BankID. When finished you will recieve a token that can be sent to the status endpoint to recieve a jwt token when authorized through BankID.</p>
		 * @summary Login
		 * @param {string} socialSecurityNumber Swedish social security number connected to BankID
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		login(socialSecurityNumber: string, options?: any) {
			return LoginApiFp(configuration).login(socialSecurityNumber, options)(fetch, basePath);
		},
		/**
		 * <p>Recieve the status of the order token after the user has approved the authorization request in the BankID app, this endpoint will return a jwt token that can be used for the subsequential requests. This request will wait up until two minutes for a response.</p>
		 * @summary Wait for Jwt token
		 * @param {string} order Order token received from the /login endpoint
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		waitForToken(order: string, options?: any) {
			return LoginApiFp(configuration).waitForToken(order, options)(fetch, basePath);
		},
	};
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
	/**
	 * <p>Get auth cookie for BankID login. This endpoint will initiate a login and require the user to login through BankID. When finished you will recieve a token that can be sent to the status endpoint to recieve a jwt token when authorized through BankID.</p>
	 * @summary Login
	 * @param {string} socialSecurityNumber Swedish social security number connected to BankID
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LoginApi
	 */
	public login(socialSecurityNumber: string, options?: any) {
		return LoginApiFp(this.configuration).login(socialSecurityNumber, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Recieve the status of the order token after the user has approved the authorization request in the BankID app, this endpoint will return a jwt token that can be used for the subsequential requests. This request will wait up until two minutes for a response.</p>
	 * @summary Wait for Jwt token
	 * @param {string} order Order token received from the /login endpoint
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LoginApi
	 */
	public waitForToken(order: string, options?: any) {
		return LoginApiFp(this.configuration).waitForToken(order, options)(this.fetch, this.basePath);
	}

}
/**
 * UtilityApi - fetch parameter creator
 * @export
 */
export const UtilityApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Download content from an url using the jwt token</p>
		 * @summary Download
		 * @param {string} url URL to download
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		download(url: string, options: any = {}): FetchArgs {
			// verify required parameter 'url' is not null or undefined
			if (url === null || url === undefined) {
				throw new RequiredError('url', 'Required parameter url was null or undefined when calling download.');
			}
			const localVarPath = `/download/`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http basic authentication required
			if (configuration && (configuration.username || configuration.password)) {
				localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
			}

			if (url !== undefined) {
				localVarQueryParameter['url'] = url;
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * UtilityApi - functional programming interface
 * @export
 */
export const UtilityApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Download content from an url using the jwt token</p>
		 * @summary Download
		 * @param {string} url URL to download
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		download(url: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = UtilityApiFetchParamCreator(configuration).download(url, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response;
					} else {
						throw response;
					}
				});
			};
		},
	}
};

/**
 * UtilityApi - factory interface
 * @export
 */
export const UtilityApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 * <p>Download content from an url using the jwt token</p>
		 * @summary Download
		 * @param {string} url URL to download
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		download(url: string, options?: any) {
			return UtilityApiFp(configuration).download(url, options)(fetch, basePath);
		},
	};
};

/**
 * UtilityApi - object-oriented interface
 * @export
 * @class UtilityApi
 * @extends {BaseAPI}
 */
export class UtilityApi extends BaseAPI {
	/**
	 * <p>Download content from an url using the jwt token</p>
	 * @summary Download
	 * @param {string} url URL to download
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UtilityApi
	 */
	public download(url: string, options?: any) {
		return UtilityApiFp(this.configuration).download(url, options)(this.fetch, this.basePath);
	}

}
